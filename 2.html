<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tableau分析工具</title>
  <meta name="description" content="一款强大的Tableau工作簿分析工具，可自动提取和可视化计算字段之间的依赖关系，支持多种格式导出，帮助您更好地理解和维护复杂的Tableau工作簿。完全本地运行，确保数据安全。">
  <meta name="keywords" content="Tableau, 数据分析, 字段关系, 可视化, 计算字段, 依赖分析, 文档生成, 工作簿分析, 函数分析, 项目迁移">
  <link rel="icon" type="image/svg+xml" href="icon.svg">
  <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.28/jspdf.plugin.autotable.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>
  <script src="https://cdn.sheetjs.com/xlsx-0.19.3/package/dist/xlsx.full.min.js"></script>
  <style>
    :root {
      --primary: #FFED29;
      /* 明亮黄色 - 更加鲜艳醒目 */
      --primary-light: #FFF176;
      /* 浅色调 */
      --primary-dark: #FBC02D;
      /* 深色调 - 用于悬停效果 */
      --primary-transparent: rgba(255, 237, 41, 0.08);
      /* 透明黄色背景 */
      --bg: #f9fafb;
      --card: #ffffff;
      --text: #111827;
      --text-muted: #6b7280;
      --border: #e5e7eb;
      --success: #10b981;
      --radius: 12px;
      --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
      --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', 'SF Pro Display', -apple-system, BlinkMacSystemFont, sans-serif;
      background: var(--bg);
      color: var(--text);
      line-height: 1.5;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 2rem;
    }

    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 2rem;
    }

    .logo {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }

    .logo-icon {
      width: 40px;
      height: 40px;
      background: var(--primary);
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      font-size: 20px;
      color: #24231b;
      /* 深色文字在黄色背景上更易读 */
      box-shadow: 0 2px 10px rgba(255, 237, 41, 0.4);
      /* 添加发光效果 */
    }

    .logo-text {
      font-weight: 700;
      font-size: 1.5rem;
      color: var(--text);
    }

    .nav {
      display: flex;
      gap: 1.5rem;
    }

    .nav-item {
      color: var(--text-muted);
      text-decoration: none;
      font-weight: 500;
      padding: 0.5rem 0;
      border-bottom: 2px solid transparent;
      transition: all 0.2s;
    }

    .nav-item.active {
      color: var(--primary-dark);
      border-bottom-color: var(--primary);
    }

    .nav-item:hover:not(.active) {
      color: var(--text);
    }

    .card {
      background: var(--card);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 2rem;
      margin-bottom: 2rem;
      border-top: 3px solid var(--primary);
      /* 添加顶部边框突显主题色 */
      transition: transform 0.3s ease;
    }

    .card:hover {
      /* transform: translateY(-3px);
      box-shadow: var(--shadow-lg); */
    }

    .card-title {
      font-size: 1.25rem;
      font-weight: 600;
      margin-bottom: 1.5rem;
      display: flex;
      align-items: center;
      gap: 0.75rem;
      color: #43402f;
      /* 稍微深一点的文字颜色 */
    }

    .card-icon {
      width: 24px;
      height: 24px;
      color: var(--primary-dark);
    }

    .upload-area {
      border: 2px dashed var(--border);
      border-radius: var(--radius);
      padding: 1rem;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .upload-area:hover {
      border-color: var(--primary);
      background: var(--primary-transparent);
      box-shadow: 0 0 15px rgba(255, 237, 41, 0.2);
      /* 添加发光效果 */
    }

    .upload-icon {
      width: 32px;
      height: 32px;
      flex-shrink: 0;
      color: var(--primary-dark);
    }

    .upload-text {
      font-size: 1rem;
      margin-bottom: 0.25rem;
      font-weight: 500;
    }

    .upload-hint {
      color: var(--text-muted);
      font-size: 0.9rem;
      margin-bottom: 0.75rem;
    }

    .upload-actions {
      display: flex;
      align-items: center;
      gap: 1rem;
      margin-top: 0.5rem;
    }

    .btn {
      background: var(--primary);
      color: #24231b;
      /* 深色文字在黄色背景上更易读 */
      border: none;
      border-radius: 6px;
      padding: 0.6rem 1.2rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      font-size: 0.95rem;
    }

    .btn-sm {
      padding: 0.4rem 0.8rem;
      font-size: 0.85rem;
    }

    .btn:hover {
      background: var(--primary-dark);
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
    }

    .btn-outline {
      background: transparent;
      border: 1px solid var(--primary);
      color: var(--primary-dark);
    }

    .btn-outline:hover {
      background: var(--primary-transparent);
    }

    .options-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 1rem;
      margin: 1.5rem 0;
    }

    .option-item {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      padding: 0.5rem;
      border-radius: 4px;
      transition: background 0.2s;
    }

    .option-item:hover {
      background: var(--primary-transparent);
    }

    .option-checkbox {
      width: 18px;
      height: 18px;
      accent-color: var(--primary-dark);
    }

    .option-label {
      font-size: 0.9375rem;
    }

    /* 移除标签页样式 */
    .mermaid-container {
      background: var(--bg);
      border-radius: 8px;
      padding: 1rem;
      min-height: 600px;
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 1px solid var(--border);
      overflow: auto;
    }

    #mermaidDiv {
      width: 100%;
      height: 100%;
      min-height: 580px;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      table-layout: fixed;
    }

    th,
    td {
      padding: 0.75rem 1rem;
      text-align: left;
      border-bottom: 1px solid var(--border);
      word-wrap: break-word;
      overflow-wrap: break-word;
      max-width: 250px;
      white-space: normal;
    }

    th:nth-child(4), td:nth-child(4) {
      max-width: 300px;
    }

    th {
      font-weight: 600;
      color: var(--text-muted);
      background: var(--bg);
      position: sticky;
      top: 0;
      z-index: 10;
    }

    tr:hover td {
      background: var(--primary-transparent);
    }

    .table-container {
      scrollbar-width: thin;
      scrollbar-color: var(--primary-dark) var(--bg);
    }

    .table-container::-webkit-scrollbar {
      width: 8px;
    }

    .table-container::-webkit-scrollbar-track {
      background: var(--bg);
    }

    .table-container::-webkit-scrollbar-thumb {
      background-color: var(--primary-dark);
      border-radius: 4px;
    }



    .file-list {
      list-style: none;
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 1rem;
    }

    .file-item {
      background: var(--bg);
      border-radius: 8px;
      padding: 1rem;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      transition: all 0.2s;
      border-left: 3px solid var(--primary);
    }

    .file-item:hover {
      box-shadow: var(--shadow);
      transform: translateY(-2px);
      background: white;
    }

    .file-icon {
      width: 40px;
      height: 40px;
      margin-bottom: 0.5rem;
      color: var(--primary-dark);
    }

    .file-name {
      font-weight: 500;
      font-size: 0.9375rem;
    }

    .file-info {
      color: var(--text-muted);
      font-size: 0.75rem;
    }

    .log-container {
      border-radius: 8px;
      padding: 0.75rem;
      font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
      font-size: 0.8rem;
      line-height: 1.4;
      border: 1px solid var(--border-light);
      overflow: hidden;
    }

    .log-entry {
      margin-bottom: 0.25rem;
      display: flex;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .log-time {
      color: var(--text-muted);
      margin-right: 0.75rem;
      flex-shrink: 0;
    }

    .log-message.success {
      color: var(--success);
    }

    /* 添加一些微妙的动画效果 */
    .card,
    .btn,
    .file-item {
      transition: all 0.3s ease;
    }

    /* 隐藏元素 */
    .hidden {
      display: none !important;
    }

    /* 响应式设计调整 */
    @media (max-width: 768px) {
      .container {
        padding: 1rem;
      }

      .header {
        flex-direction: column;
        align-items: flex-start;
        gap: 1rem;
      }

      .nav {
        width: 100%;
        overflow-x: auto;
        padding-bottom: 0.5rem;
      }

      .card {
        padding: 1.5rem;
      }

      .options-grid {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>

<body>
  <div class="container">
    <header class="header">
      <div class="logo">
        <div class="logo-icon">T</div>
        <div class="logo-text">Tableau分析工具</div>
      </div>
    </header>

    <div class="card">
      <h2 class="card-title">
        <svg class="card-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
          stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
          <polyline points="17 8 12 3 7 8"></polyline>
          <line x1="12" y1="3" x2="12" y2="15"></line>
        </svg>
        上传Tableau工作簿
      </h2>
      <div class="card-content" style="display: flex; gap: 1rem; flex-wrap: wrap;">
        <div style="flex: 0 0 350px; display: flex; align-items: center;">
          <div class="upload-area" id="dropArea" style="width: 100%; padding: 0.5rem 0.75rem; min-height: auto; display: flex; align-items: center; gap: 0.75rem;">
            <svg class="upload-icon" style="width: 24px; height: 24px; flex-shrink: 0;" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
              stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
              <polyline points="17 8 12 3 7 8"></polyline>
              <line x1="12" y1="3" x2="12" y2="15"></line>
            </svg>
            <div style="flex: 1; min-width: 0;">
              <h3 class="upload-text" style="margin-bottom: 0; font-size: 0.9rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">拖放文件或点击选择</h3>
              <p class="upload-hint" style="margin-bottom: 0; font-size: 0.75rem;">支持.twbx和.twb格式</p>
            </div>
            <input type="file" id="fileInput" accept=".twbx,.twb" style="display: none;">
            <button class="btn" id="selectFileBtn" style="padding: 0.3rem 0.6rem; font-size: 0.8rem; white-space: nowrap; flex-shrink: 0;">
              <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none"
                stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                <polyline points="17 8 12 3 7 8"></polyline>
                <line x1="12" y1="3" x2="12" y2="15"></line>
              </svg>
              选择文件
            </button>
            <div id="loading" class="hidden" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(255,255,255,0.9); padding: 0.75rem; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); z-index: 10;">
              <div style="width: 24px; height: 24px; border: 2px solid var(--border); border-top-color: var(--primary); border-radius: 50%; margin: 0 auto; animation: spin 1s linear infinite;"></div>
              <p style="margin-top: 0.25rem; font-size: 0.75rem;">处理中...</p>
            </div>
          </div>
        </div>

        <div style="flex: 0 0 350px;">
          <h3 style="font-size: 0.9rem; margin-bottom: 0.25rem; display: flex; align-items: center; gap: 0.5rem;">
            <svg style="width: 14px; height: 14px;" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
              stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M21 3v8a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V3"></path>
              <path d="M22 10v8a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2v-8"></path>
              <path d="M22 10l-10.4 7.8a2 2 0 0 1-2.4 0L2 10"></path>
            </svg>
            处理日志
          </h3>
          <div class="log-container" id="logContainer" style="height: auto; min-height: 80px;">
            <!-- 处理日志将在这里动态生成 -->
          </div>
        </div>
      </div>



      <div style="margin-top: 1rem;">
        <div style="display: flex; align-items: center; margin-bottom: 0.75rem;">
          <button class="btn" id="analyzeBtn" style="margin-right: 1rem;">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none"
              stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <polyline points="22 7 13.5 15.5 8.5 10.5 2 17"></polyline>
              <polyline points="16 7 22 7 22 13"></polyline>
            </svg>
            开始分析
          </button>
          <span style="font-size: 0.9rem; color: var(--text-muted); margin-right: 0.5rem;">导出格式：</span>
        </div>

        <div class="export-buttons" style="display: flex; flex-wrap: wrap; gap: 0.5rem;">
          <div style="display: flex; align-items: center; margin-right: 1rem;">
            <span style="font-size: 0.85rem; color: var(--text-muted); margin-right: 0.5rem;">图表：</span>
            <button class="btn btn-sm btn-outline" id="exportSVGBtn" disabled style="padding: 0.25rem 0.5rem; font-size: 0.8rem;">
              <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none"
                stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                <polyline points="7 10 12 15 17 10"></polyline>
                <line x1="12" y1="15" x2="12" y2="3"></line>
              </svg>
              SVG
            </button>
            <button class="btn btn-sm btn-outline" id="exportPNGBtn" disabled style="padding: 0.25rem 0.5rem; font-size: 0.8rem;">
              <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none"
                stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                <polyline points="7 10 12 15 17 10"></polyline>
                <line x1="12" y1="15" x2="12" y2="3"></line>
              </svg>
              PNG
            </button>
          </div>

          <div style="display: flex; align-items: center; margin-right: 1rem;">
            <span style="font-size: 0.85rem; color: var(--text-muted); margin-right: 0.5rem;">数据：</span>
            <button class="btn btn-sm btn-outline" id="exportExcelBtn" disabled style="padding: 0.25rem 0.5rem; font-size: 0.8rem;">
              <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none"
                stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                <polyline points="14 2 14 8 20 8"></polyline>
                <line x1="16" y1="13" x2="8" y2="13"></line>
                <line x1="16" y1="17" x2="8" y2="17"></line>
                <polyline points="10 9 9 9 8 9"></polyline>
              </svg>
              Excel
            </button>
            <button class="btn btn-sm btn-outline" id="exportPDFBtn" disabled style="padding: 0.25rem 0.5rem; font-size: 0.8rem;">
              <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none"
                stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                <polyline points="14 2 14 8 20 8"></polyline>
                <line x1="16" y1="13" x2="8" y2="13"></line>
                <line x1="16" y1="17" x2="8" y2="17"></line>
                <polyline points="10 9 9 9 8 9"></polyline>
              </svg>
              PDF
            </button>

          </div>

          <div style="display: flex; align-items: center;">
            <span style="font-size: 0.85rem; color: var(--text-muted); margin-right: 0.5rem;">依赖关系：</span>
            <button class="btn btn-sm btn-outline" id="exportJSONBtn" disabled style="padding: 0.25rem 0.5rem; font-size: 0.8rem;">
              <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none"
                stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                <polyline points="7 10 12 15 17 10"></polyline>
                <line x1="12" y1="15" x2="12" y2="3"></line>
              </svg>
              JSON
            </button>
          </div>
        </div>
      </div>
    </div>

    <div class="card">
      <h2 class="card-title">
        <svg class="card-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
          stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <polyline points="22 12 18 12 15 21 9 3 6 12 2 12"></polyline>
        </svg>
        分析结果
      </h2>

      <div class="card">
        <h2 class="card-title">
          <svg class="card-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
            stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
            <polyline points="14 2 14 8 20 8"></polyline>
            <line x1="16" y1="13" x2="8" y2="13"></line>
            <line x1="16" y1="17" x2="8" y2="17"></line>
            <polyline points="10 9 9 9 8 9"></polyline>
          </svg>
          字段列表
        </h2>
        <div class="table-container" style="height: 400px; overflow-y: auto; border: 1px solid var(--border); border-radius: 8px;">
          <table id="fieldsTable">
            <thead>
              <tr>
                <th>字段名称</th>
                <th>数据类型</th>
                <th>字段类型</th>
                <th>计算公式</th>
                <th>字段ID</th>
                <th>数据源</th>
              </tr>
            </thead>
            <tbody id="fieldsTableBody">
              <!-- 字段数据将在这里动态生成 -->
            </tbody>
          </table>
        </div>
      </div>

      <div class="card">
        <h2 class="card-title">
          <svg class="card-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
            stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <polyline points="22 12 18 12 15 21 9 3 6 12 2 12"></polyline>
          </svg>
          依赖关系图
          <div style="margin-left: auto; display: flex; align-items: center; gap: 0.5rem;">
            <button id="zoomInBtn" class="btn btn-sm" style="padding: 0.25rem 0.5rem;">
              <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="11" cy="11" r="8"></circle>
                <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                <line x1="11" y1="8" x2="11" y2="14"></line>
                <line x1="8" y1="11" x2="14" y2="11"></line>
              </svg>
              放大
            </button>
            <button id="zoomOutBtn" class="btn btn-sm" style="padding: 0.25rem 0.5rem;">
              <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="11" cy="11" r="8"></circle>
                <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                <line x1="8" y1="11" x2="14" y2="11"></line>
              </svg>
              缩小
            </button>
            <button id="resetZoomBtn" class="btn btn-sm" style="padding: 0.25rem 0.5rem;">
              <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M3 2v6h6"></path>
                <path d="M21 12A9 9 0 0 0 6 5.3L3 8"></path>
                <path d="M21 22v-6h-6"></path>
                <path d="M3 12a9 9 0 0 0 15 6.7l3-2.7"></path>
              </svg>
              重置
            </button>
          </div>
        </h2>
        <div class="mermaid-container" id="mermaidContainer">
          <!-- 这里将显示Mermaid图表 -->
          <div id="mermaidDiv"></div>
        </div>
      </div>




    </div>
  </div>

  <script>
    // 存储处理后的数据
    let processedData = null;
    let currentFile = null;
    let exportedFiles = [];

    // 初始化页面元素
    document.addEventListener('DOMContentLoaded', function() {
      // 初始化mermaid
      mermaid.initialize({
        startOnLoad: true,
        theme: 'default',
        securityLevel: 'loose',
        flowchart: {
          useMaxWidth: false,
          htmlLabels: true
        }
      });

      // 初始化文件上传
      const fileInput = document.getElementById('fileInput');
      const selectFileBtn = document.getElementById('selectFileBtn');
      const dropArea = document.getElementById('dropArea');
      const analyzeBtn = document.getElementById('analyzeBtn');

      // 点击选择文件按钮时触发文件输入
      selectFileBtn.addEventListener('click', () => {
        fileInput.click();
      });

      // 文件选择后处理
      fileInput.addEventListener('change', handleFileSelect);

      // 拖放文件处理
      dropArea.addEventListener('dragover', (e) => {
        e.preventDefault();
        dropArea.classList.add('upload-area-active');
      });

      dropArea.addEventListener('dragleave', () => {
        dropArea.classList.remove('upload-area-active');
      });

      dropArea.addEventListener('drop', (e) => {
        e.preventDefault();
        dropArea.classList.remove('upload-area-active');

        if (e.dataTransfer.files.length) {
          const file = e.dataTransfer.files[0];
          if (isValidFile(file)) {
            currentFile = file;
            updateFileInfo(file);
          } else {
            addLogEntry('错误', `不支持的文件类型: ${file.name}。请上传.twb或.twbx文件。`);
          }
        }
      });

      // 分析按钮点击事件
      analyzeBtn.addEventListener('click', () => {
        if (currentFile) {
          processTableauFile(currentFile);
        } else {
          addLogEntry('错误', '请先选择一个Tableau工作簿文件');
        }
      });

      // 导出按钮事件
      document.getElementById('exportSVGBtn').addEventListener('click', downloadSVG);
      document.getElementById('exportPNGBtn').addEventListener('click', downloadPNG);
      document.getElementById('exportExcelBtn').addEventListener('click', exportExcel);
      document.getElementById('exportPDFBtn').addEventListener('click', exportPDF);

      document.getElementById('exportJSONBtn').addEventListener('click', exportJSON);
    });

    // Mermaid初始化
    mermaid.initialize({
      startOnLoad: false,
      theme: 'default',
      securityLevel: 'loose',
      maxTextSize: 100000,
      flowchart: {
        htmlLabels: true,
        curve: 'basis'
      }
    });

    // 检查文件类型是否有效
    function isValidFile(file) {
      const fileName = file.name.toLowerCase();
      return fileName.endsWith('.twb') || fileName.endsWith('.twbx');
    }

    // 处理文件选择
    function handleFileSelect(e) {
      const file = e.target.files[0];
      if (file && isValidFile(file)) {
        currentFile = file;
        updateFileInfo(file);
      } else if (file) {
        addLogEntry('错误', `不支持的文件类型: ${file.name}。请上传.twb或.twbx文件。`);
      }
    }

    // 更新文件信息显示
    function updateFileInfo(file) {
      const uploadText = document.querySelector('.upload-text');
      uploadText.textContent = `已选择: ${file.name}`;
      addLogEntry('信息', `已选择文件: ${file.name}`);
    }

    // 添加日志条目
    function addLogEntry(type, message) {
      const logContainer = document.getElementById('logContainer');
      const now = new Date();
      const timeStr = `[${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}:${now.getSeconds().toString().padStart(2, '0')}]`;

      const logEntry = document.createElement('div');
      logEntry.className = 'log-entry';

      const logTime = document.createElement('div');
      logTime.className = 'log-time';
      logTime.textContent = timeStr;

      const logMessage = document.createElement('div');
      logMessage.className = 'log-message';
      if (type === '成功') logMessage.classList.add('success');
      if (type === '错误') logMessage.style.color = '#e53e3e';
      logMessage.textContent = message;

      logEntry.appendChild(logTime);
      logEntry.appendChild(logMessage);

      // 限制日志条目数量，保留最新的4条
      while (logContainer.children.length >= 4) {
        logContainer.removeChild(logContainer.firstChild);
      }

      logContainer.appendChild(logEntry);

      // 自动滚动到底部
      logContainer.scrollTop = logContainer.scrollHeight;
    }

    // 处理Tableau文件
    async function processTableauFile(file) {
      const loading = document.getElementById('loading');
      loading.classList.remove('hidden');

      // 清空之前的结果
      document.getElementById('fieldsTableBody').innerHTML = '';
      document.getElementById('mermaidDiv').innerHTML = '';

      // 禁用导出按钮
      setExportButtonsState(true);

      addLogEntry('信息', `开始处理文件: ${file.name}`);

      try {
        // 确保mermaid已初始化
        if (typeof mermaid !== 'undefined') {
          mermaid.initialize({
            startOnLoad: true,
            theme: 'default',
            securityLevel: 'loose',
            flowchart: {
              useMaxWidth: false,
              htmlLabels: true
            }
          });
        } else {
          addLogEntry('错误', 'Mermaid库未加载，无法渲染图表');
        }

        // 处理不同类型的文件
        if (file.name.toLowerCase().endsWith('.twbx')) {
          await processTWBX(file);
        } else if (file.name.toLowerCase().endsWith('.twb')) {
          await processTWB(file);
        }
      } catch (error) {
        console.error('处理文件时出错:', error);
        addLogEntry('错误', `处理文件时出错: ${error.message}`);
      } finally {
        loading.classList.add('hidden');
      }
    }

    // 处理TWBX文件
    async function processTWBX(file) {
      try {
        addLogEntry('信息', '正在解压TWBX文件...');
        const zip = new JSZip();
        const contents = await zip.loadAsync(file);

        // 查找.twb文件
        let twbFile = null;
        for (let filename in contents.files) {
          if (filename.endsWith('.twb')) {
            twbFile = contents.files[filename];
            break;
          }
        }

        if (!twbFile) {
          throw new Error('没有找到.twb文件');
        }

        addLogEntry('信息', '正在提取TWB内容...');
        const twbContent = await twbFile.async('text');
        processTWBContent(twbContent);
      } catch (error) {
        console.error('处理TWBX文件时出错:', error);
        throw error;
      }
    }

    // 处理TWB文件
    async function processTWB(file) {
      try {
        addLogEntry('信息', '正在读取TWB文件...');
        const reader = new FileReader();

        const twbContent = await new Promise((resolve, reject) => {
          reader.onload = (e) => resolve(e.target.result);
          reader.onerror = (e) => reject(new Error('读取文件失败'));
          reader.readAsText(file);
        });

        processTWBContent(twbContent);
      } catch (error) {
        console.error('处理TWB文件时出错:', error);
        throw error;
      }
    }

    // 处理TWB内容
    function processTWBContent(twbContent) {
      addLogEntry('信息', '正在解析XML内容...');
      const parser = new DOMParser();
      const xmlDoc = parser.parseFromString(twbContent, 'text/xml');

      // 提取字段关系并生成图表代码
      addLogEntry('信息', '正在提取字段关系...');
      const fieldData = extractFieldRelationships(xmlDoc);
      console.log('提取的字段关系:', fieldData);

      if (!fieldData.fields.length) {
        addLogEntry('错误', '未找到任何字段关系');
        throw new Error('未找到任何字段关系');
      }

      addLogEntry('信息', `已找到 ${fieldData.fields.length} 个字段，其中计算字段 ${fieldData.fields.filter(f => f.type === 'calculation').length} 个`);

      // 更新字段表格
      updateFieldsTable(fieldData.fields);

      // 生成并渲染图表
      addLogEntry('信息', '正在生成依赖关系图...');
      const mermaidCode = generateMermaidCode(fieldData);
      renderMermaidDiagram(mermaidCode);

      // 保存处理后的数据
      processedData = fieldData;

      // 启用导出按钮
      setExportButtonsState(false);



      addLogEntry('成功', '分析完成！可以查看结果并导出数据。');
    }

    /**
     * 从解析后的 TWB XML 文档中提取字段和计算信息
     * @param {XMLDocument} xmlDoc - 解析后的 XML 文档对象
     * @returns {object} - 返回包含字段列表和关系列表的对象 { fields: [], relationships: [] }
     */
    function extractFieldRelationships(xmlDoc) {
      const allFields = []; // 用于存储所有提取的字段信息
      const relationships = []; // 用于存储字段间的依赖关系
      let counter = 0; // 简单的计数器，用于生成唯一标识或排序

      try {
        // 获取所有的 <datasource> 元素
        const datasources = xmlDoc.getElementsByTagName('datasource');
        console.log('找到数据源:', datasources.length);

        // 遍历每个数据源
        for (const ds of datasources) {
          // 获取数据源名称和标题 (优先使用标题 caption, 否则用 name)
          const dsName = ds.getAttribute('name') || 'Unknown Datasource'; // 数据源内部名称
          const dsCaption = ds.getAttribute('caption') || dsName; // 数据源显示名称
          const isParameterDs = dsName.toLowerCase() === 'parameters'; // 判断是否是参数数据源

          // 获取数据源下的所有 <column> 元素
          const columns = ds.getElementsByTagName('column');
          console.log(`数据源 ${dsCaption} 找到列:`, columns.length);

          for (const col of columns) {
            // 获取字段的各种属性
            const fieldId = col.getAttribute('id') || `[${col.getAttribute('name') || `col_${counter}`}]`; // 字段ID (可能需要生成)
            const fieldName = col.getAttribute('name') || fieldId; // 字段名
            const fieldCaption = col.getAttribute('caption') || fieldName; // 字段标题 (显示用)

            // 查找字段下的 <calculation> 元素
            const calculationTag = col.getElementsByTagName('calculation')[0];
            const fieldCalculation = calculationTag ? calculationTag.getAttribute('formula') : null; // 获取计算公式

            // 查找字段描述
            const descTag = col.getElementsByTagName('desc')[0]; // 查找 <desc> 标签
            // 描述通常在 <formatted-text><run>...</run></formatted-text> 结构里
            const descriptionElement = descTag ? descTag.getElementsByTagName('formatted-text')[0]?.getElementsByTagName('run')[0] : null;
            const fieldDesc = descriptionElement ? descriptionElement.textContent : null; // 获取描述文本

            // 构建字段数据对象
            const fieldData = {
              counter: counter++, // 计数器
              datasource_name: dsName, // 数据源内部名
              datasource_caption: dsCaption, // 数据源显示名
              alias: col.getAttribute('alias'), // 别名
              field_calculation: fieldCalculation, // 计算公式 (后面可能会被友好名称替换)
              field_calculation_bk: fieldCalculation, // 备份原始计算公式，用于依赖分析
              field_caption: fieldCaption, // 字段显示名
              field_datatype: col.getAttribute('datatype'), // 数据类型 (string, integer, etc.)
              field_def_agg: col.getAttribute('default-aggregation'), // 默认聚合方式 (sum, avg, etc.)
              field_desc: fieldDesc, // 字段描述
              field_hidden: col.getAttribute('hidden') === 'true', // 是否隐藏
              field_id: `[${fieldName}]`, // 字段ID (通常是 [Name] 格式)
              // 语义角色 (近似判断，TWB XML 结构可能变化)
              field_is_nominal: col.getAttribute('semantic-role') === '[Nominal]',
              field_is_ordinal: col.getAttribute('semantic-role') === '[Ordinal]',
              field_is_quantitative: col.getAttribute('semantic-role') === '[Measure]',
              field_name: fieldName, // 字段内部名
              field_role: col.getAttribute('role'), // 角色 (dimension, measure)
              field_type: col.getAttribute('type'), // 类型 (quantitative, ordinal, nominal)
              // 兼容旧代码的属性
              name: fieldCaption, // 兼容旧代码的字段名
              datatype: col.getAttribute('datatype') || 'unknown', // 兼容旧代码的数据类型
              formula: fieldCalculation, // 兼容旧代码的计算公式
              id: `[${fieldName}]`, // 兼容旧代码的ID
              datasource: dsCaption // 兼容旧代码的数据源名
            };

            // 初步分类字段类型 (后续会精炼)
            if (isParameterDs || (col.parentElement && col.parentElement.nodeName === 'datasource' && col.parentElement.getAttribute('name')?.toLowerCase() === 'parameters')) {
              // 如果字段属于 'Parameters' 数据源，则分类为参数
              fieldData.category = 'Parameters';
              fieldData.type = 'parameter'; // 兼容旧代码
            } else if (fieldCalculation !== null) {
              // 如果有计算公式，则分类为计算字段
              fieldData.category = 'Calculated_Field';
              fieldData.type = 'calculation'; // 兼容旧代码
            } else {
              // 否则为默认字段
              fieldData.category = 'Default_Field';
              fieldData.type = 'field'; // 兼容旧代码
            }

            allFields.push(fieldData); // 将字段数据添加到列表
          }

          // 特殊处理 <datasource name='Parameters'> 下直接列出的 <param> 元素
          if (isParameterDs) {
            const parameters = ds.getElementsByTagName('param'); // 查找 <param> 标签 (标签名可能需确认)
            for (const param of parameters) {
              const fieldId = `[${param.getAttribute('name')}]`; // 参数的 ID 通常是 [ParamName]
              // 检查是否已通过 <column> 添加过 (不太可能，但以防万一)
              if (!allFields.some(f => f.field_id === fieldId && f.datasource_name === 'Parameters')) {
                // 如果未添加，则构建参数的字段数据并添加
                allFields.push({
                  counter: counter++,
                  datasource_name: dsName,
                  datasource_caption: dsCaption,
                  alias: param.getAttribute('alias'),
                  field_calculation: null, // 参数通常没有计算公式
                  field_calculation_bk: null,
                  field_caption: param.getAttribute('caption') || param.getAttribute('name'), // 显示名
                  field_datatype: param.getAttribute('datatype'), // 数据类型
                  field_desc: null, // 参数一般没有 <desc>
                  field_hidden: false, // 参数通常不隐藏
                  field_id: fieldId, // ID
                  field_name: param.getAttribute('name'), // 内部名
                  field_role: 'parameter', // 角色
                  field_type: 'quantitative', // 类型 (通常，取决于参数定义)
                  category: 'Parameters', // 分类为参数
                  // 兼容旧代码的属性
                  name: param.getAttribute('caption') || param.getAttribute('name'),
                  datatype: param.getAttribute('datatype') || 'unknown',
                  type: 'parameter',
                  id: fieldId,
                  datasource: dsCaption
                });
              }
            }
          }
        }

        // --- 数据后处理 ---

        // 1. 创建字段 ID -> 友好名称 [FieldName] 的映射，用于替换计算公式中的 ID
        const calcMapRaw = new Map(); // key: 原始ID (无括号), value: 友好名称 [FieldName]
        allFields.forEach(field => {
          // 包含计算字段、参数和默认字段，因为它们都可能在其他计算中被引用
          const cleanId = field.field_id.replace(/[\[\]]/g, ''); // 移除 ID 中的方括号
          const friendlyName = `[${field.field_caption || field.field_name}]`; // 使用 Caption 或 Name 作为友好名称
          // 优先使用计算字段/参数的名称，避免被同名默认字段覆盖
          if (field.category === 'Calculated_Field' || field.category === 'Parameters') {
            calcMapRaw.set(cleanId, friendlyName);
          } else if (!calcMapRaw.has(cleanId)) { // 如果不是计算/参数，且该 cleanId 还未被映射，则添加默认字段的映射
            calcMapRaw.set(cleanId, friendlyName);
          }
        });

        // 2. 替换计算公式中的字段 ID 为友好名称 (对 `field_calculation` 进行修改)
        allFields.forEach(field => {
          if (field.field_calculation) { // 只处理有计算公式的字段
            let formula = field.field_calculation;
            // 获取所有映射的 key (原始ID，无括号)，按长度降序排序
            // 排序是为了优先替换长名称，避免如 [Sales] 错误替换 [Sales Amount] 的一部分
            const sortedKeys = Array.from(calcMapRaw.keys()).sort((a, b) => b.length - a.length);

            sortedKeys.forEach(keyId => {
              // 使用正则表达式精确替换 `[原始ID]` 为对应的 `[友好名称]`
              // 需要转义 keyId 中的正则表达式特殊字符
              const escapedKeyId = keyId.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
              // 创建正则表达式，匹配方括号包围的、转义后的 keyId，全局替换，忽略大小写 (g, i)
              const regex = new RegExp(`\\[${escapedKeyId}\\]`, 'gi');
              const replacement = calcMapRaw.get(keyId); // 获取对应的友好名称
              if (replacement) {
                formula = formula.replace(regex, replacement);
              }
            });
            field.field_calculation = formula; // 更新字段对象的计算公式
            field.formula = formula; // 同时更新兼容旧代码的属性
          }
        });

        // 3. 过滤重复字段 (特别是参数可能在多个数据源下出现)
        // 策略：优先保留来自 'Parameters' 数据源的参数，对于其他字段保留第一次出现的
        const uniqueFields = []; // 存储去重后的字段
        const seenFieldIds = new Set(); // 存储已经添加的字段 ID

        // 先按数据源排序，将 'Parameters' 数据源的字段排在前面
        allFields
          .sort((a, b) => {
            if (a.datasource_name === 'Parameters' && b.datasource_name !== 'Parameters') return -1; // a 来自 Parameters，排前面
            if (a.datasource_name !== 'Parameters' && b.datasource_name === 'Parameters') return 1; // b 来自 Parameters，排前面
            return a.counter - b.counter; // 其他情况保持原始相对顺序
          })
          .forEach(field => {
            // 如果这个字段的 ID 还没见过，就添加到 uniqueFields 列表，并记录 ID
            if (!seenFieldIds.has(field.field_id)) {
              uniqueFields.push(field);
              seenFieldIds.add(field.field_id);
            }
            // (这里的逻辑保证了如果 Parameters 数据源的同 ID 字段先出现，就会被保留)
          });

        // 4. 最终排序，用于表格显示
        const preferenceOrder = ['Parameters', 'Calculated_Field', 'Default_Field']; // 定义类型优先级
        uniqueFields.sort((a, b) => {
          const typeAIndex = preferenceOrder.indexOf(a.category); // 获取 a 的类型优先级
          const typeBIndex = preferenceOrder.indexOf(b.category); // 获取 b 的类型优先级
          if (typeAIndex !== typeBIndex) return typeAIndex - typeBIndex; // 按类型优先级排序

          // 类型相同时，按数据源名称排序
          if (a.datasource_caption < b.datasource_caption) return -1;
          if (a.datasource_caption > b.datasource_caption) return 1;

          // 数据源名称也相同时，按字段名称排序
          if (a.field_name < b.field_name) return -1;
          if (a.field_name > b.field_name) return 1;

          return a.counter - b.counter; // 最后按原始顺序 (counter) 排序
        });

        // 5. 提取依赖关系
        uniqueFields.forEach(field => {
          if (field.field_calculation) { // 只处理有计算公式的字段
            // 提取公式中的所有字段引用 [Field]
            const matches = field.field_calculation.match(/\[([^\]]+)\]/g);
            if (matches) {
              // 提取引用的字段名（去掉方括号）
              const dependencies = matches
                .map(m => m.slice(1, -1))
                .filter(dep => dep !== field.field_caption); // 过滤掉自引用

              // 为每个依赖添加关系
              dependencies.forEach(dep => {
                relationships.push({
                  from: dep,
                  to: field.field_caption,
                });
              });
            }
          }
        });

        // 6. 确保所有依赖关系中的字段都存在
        const allFieldNames = new Set(uniqueFields.map(f => f.field_caption));
        for (let rel of relationships) {
          if (!allFieldNames.has(rel.from)) {
            // 如果依赖关系中的来源字段不存在，则添加一个默认字段
            uniqueFields.push({
              counter: counter++,
              field_caption: rel.from,
              field_name: rel.from,
              name: rel.from,
              type: 'field',
              category: 'Default_Field',
              id: `[${rel.from}]`,
              field_id: `[${rel.from}]`,
              datasource: 'Unknown',
              datasource_caption: 'Unknown'
            });
            allFieldNames.add(rel.from); // 更新字段名集合
          }
        }

        // 7. 输出调试信息
        console.log('===== 所有字段 =====');
        uniqueFields.forEach(field => {
          if (field.type === 'calculation') {
            console.log(`${field.name} (${field.type}): ${field.formula}`);
          } else {
            console.log(`${field.name} (${field.type})`);
          }
        });

        console.log('===== 所有依赖关系 =====');
        relationships.forEach(rel => {
          console.log(`${rel.from} -> ${rel.to}`);
        });

        return {
          relationships: relationships,
          fields: uniqueFields
        };
      } catch (error) {
        console.error('提取字段关系时出错:', error);
        throw error;
      }
    }

    /**
     * 更新字段表格显示
     * @param {Array} fields - 字段数组
     */
    function updateFieldsTable(fields) {
      const tbody = document.getElementById('fieldsTableBody');
      tbody.innerHTML = '';

      fields.forEach(field => {
        const tr = document.createElement('tr');

        // 根据字段类型设置行的类名，用于样式区分
        if (field.category === 'Calculated_Field') {
          tr.classList.add('calculated-field-row');
        } else if (field.category === 'Parameters') {
          tr.classList.add('parameter-field-row');
        }

        // 字段名称
        const tdName = document.createElement('td');
        tdName.textContent = field.field_caption || field.name;
        tdName.title = field.field_desc || ''; // 如果有描述，显示为提示

        // 数据类型
        const tdDataType = document.createElement('td');
        tdDataType.textContent = field.field_datatype || field.datatype || '';

        // 字段类型
        const tdType = document.createElement('td');
        if (field.category === 'Calculated_Field') {
          tdType.textContent = '计算字段';
        } else if (field.category === 'Parameters') {
          tdType.textContent = '参数';
        } else {
          tdType.textContent = '默认字段';
        }

        // 计算公式
        const tdFormula = document.createElement('td');
        tdFormula.textContent = field.field_calculation || field.formula || '';
        if (field.field_calculation) {
          // 添加公式的样式，使其更易读
          tdFormula.classList.add('formula-cell');
        }

        // 字段ID
        const tdId = document.createElement('td');
        tdId.textContent = field.field_id || field.id || '';

        // 数据源
        const tdDatasource = document.createElement('td');
        tdDatasource.textContent = field.datasource_caption || field.datasource || '';

        // 添加所有单元格到行
        tr.appendChild(tdName);
        tr.appendChild(tdDataType);
        tr.appendChild(tdType);
        tr.appendChild(tdFormula);
        tr.appendChild(tdId);
        tr.appendChild(tdDatasource);

        tbody.appendChild(tr);
      });

      // 添加表格摘要信息
      const tableInfo = document.getElementById('tableInfo');
      if (tableInfo) {
        const calcCount = fields.filter(f => f.category === 'Calculated_Field').length;
        const paramCount = fields.filter(f => f.category === 'Parameters').length;
        const defaultCount = fields.filter(f => f.category === 'Default_Field').length;

        tableInfo.innerHTML = `共 ${fields.length} 个字段（${calcCount} 个计算字段，${paramCount} 个参数，${defaultCount} 个默认字段）`;
      }
    }

    /**
     * 生成 Mermaid 代码用于可视化字段依赖关系
     * @param {Object} data - 包含字段和关系的数据对象
     * @returns {string} - 返回 Mermaid 格式的代码字符串
     */
    function generateMermaidCode(data) {
      // --- Mermaid ID 生成与映射 ---
      // 生成 Mermaid 节点 ID (AA, AB, ..., BA, BB, ..., AAA, AAB, ...)
      const abc = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
      let collatedAbc = [];
      // 双字母组合
      for (let i = 0; i < abc.length; i++) {
        for (let j = 0; j < abc.length; j++) {
          collatedAbc.push(abc[i] + abc[j]);
        }
      }
      // 三字母组合 (以备节点过多时使用)
      for (let i = 0; i < abc.length; i++) {
        for (let j = 0; j < abc.length; j++) {
          for (let k = 0; k < abc.length; k++) {
            collatedAbc.push(abc[i] + abc[j] + abc[k]);
          }
        }
      }

      // 映射: 字段名称 -> Mermaid 短 ID
      const fieldNameToMermaidIdMap = new Map();
      // 映射: Mermaid 短 ID -> 字段显示名称 [FieldName]
      const mermaidIdToNameMap = new Map();
      // 映射: Mermaid 短 ID -> 字段类型 (用于样式和图例)
      const mermaidIdToCategoryMap = new Map();

      let nodeIndex = 0; // 用于从 collatedAbc 中获取唯一 ID

      // 为所有字段（包括默认、计算、参数）分配 Mermaid ID
      data.fields.forEach(field => {
        if (nodeIndex < collatedAbc.length) {
          const mermaidId = collatedAbc[nodeIndex++]; // 获取下一个可用 ID
          const fieldName = field.field_caption || field.name; // 使用显示名称
          fieldNameToMermaidIdMap.set(fieldName, mermaidId); // 存储映射关系
          // 存储 Mermaid ID 到显示名称的映射 (移除名称中的引号以防破坏语法)
          const displayName = `[${fieldName.replace(/["'`]/g, '')}]`;
          mermaidIdToNameMap.set(mermaidId, displayName);
          // 存储 Mermaid ID 到类型的映射
          mermaidIdToCategoryMap.set(mermaidId, field.category || field.type);
        } else {
          console.warn("警告: Mermaid ID 不足！部分字段可能无法在图中正确显示。");
        }
      });

      // --- 依赖关系分析 ---
      const links = new Set(); // 使用 Set 存储连接关系，自动去重 "A --> B"

      // 遍历所有关系，添加到连接集合
      // 限制关系数量，避免图表过于复杂
      const MAX_RELATIONSHIPS = 1800; // 设置最大关系数量
      const relationshipsToProcess = data.relationships.length > MAX_RELATIONSHIPS ?
                                     data.relationships.slice(0, MAX_RELATIONSHIPS) :
                                     data.relationships;

      if (data.relationships.length > MAX_RELATIONSHIPS) {
        console.warn(`关系数量超过限制 (${data.relationships.length} > ${MAX_RELATIONSHIPS})，只显示前 ${MAX_RELATIONSHIPS} 个关系`);
        // 检查 addLogEntry 函数是否存在
        if (typeof addLogEntry === 'function') {
          addLogEntry('警告', `关系数量过多 (${data.relationships.length})，为保证性能只显示前 ${MAX_RELATIONSHIPS} 个关系`);
        }
      }

      relationshipsToProcess.forEach(rel => {
        const fromId = fieldNameToMermaidIdMap.get(rel.from);
        const toId = fieldNameToMermaidIdMap.get(rel.to);
        if (fromId && toId) {
          links.add(`${fromId} --> ${toId}`);
        }
      });

      // --- 构建 Mermaid 代码 ---
      const uniqueNodesInLinks = new Set(); // 存储所有在连接中出现的节点 ID
      links.forEach(link => {
        const parts = link.split(' --> ');
        uniqueNodesInLinks.add(parts[0]); // 添加来源节点
        uniqueNodesInLinks.add(parts[1]); // 添加目标节点
      });

      // 将所有计算字段和参数节点也加入，确保即使它们没有连接也会被定义
      data.fields.forEach(field => {
        if (field.category === 'Calculated_Field' || field.category === 'Parameters' || field.type === 'calculation' || field.type === 'parameter') {
          const fieldName = field.field_caption || field.name;
          const mid = fieldNameToMermaidIdMap.get(fieldName);
          if (mid) uniqueNodesInLinks.add(mid);
        }
      });

      const nodeDefinitions = []; // 存储节点定义的数组，例如 AA["[节点名]"]:::foo
      const legendItems = []; // 存储图例信息的数组

      // 遍历所有需要定义的节点
      uniqueNodesInLinks.forEach(nodeId => {
        const nodeName = mermaidIdToNameMap.get(nodeId) || nodeId; // 获取节点显示名称
        const nodeCategory = mermaidIdToCategoryMap.get(nodeId); // 获取节点类型

        let nodeClass = ''; // Mermaid 节点的 CSS 类
        let legendClass = ''; // 图例条目的 CSS 类

        // 根据节点类型分配样式类
        if (nodeCategory === 'Default_Field' || nodeCategory === 'field') {
          nodeClass = ':::default-field'; // Mermaid 中应用 .default-field 样式 (浅蓝色背景)
          legendClass = 'default-field-legend'; // 图例中使用特殊颜色
        } else if (nodeCategory === 'Calculated_Field' || nodeCategory === 'calculation') {
          nodeClass = ':::calculated-field'; // 计算字段样式 (浅绿色)
          legendClass = 'calculated-field-legend';
        } else if (nodeCategory === 'Parameters' || nodeCategory === 'parameter') {
          nodeClass = ':::parameter-field'; // 参数样式 (浅紫色)
          legendClass = 'parameter-field-legend';
        }
        // 添加节点定义到数组
        nodeDefinitions.push(`${nodeId}["${nodeName}"]${nodeClass}`);
        // 添加图例信息到数组
        legendItems.push({ id: nodeId, name: nodeName, cssClass: legendClass });
      });

      // --- 生成图例 HTML ---
      // 按节点 ID 字母顺序排序图例
      legendItems.sort((a, b) => a.id.localeCompare(b.id));
      let legendHtml = '<strong>图例:</strong><ul>'; // 图例起始标签
      legendItems.forEach(item => {
        // 为每个图例项创建列表项
        legendHtml += `<li><span class="node-id ${item.cssClass}">${item.id}:</span> <span class="node-name">${item.name}</span></li>`;
      });
      legendHtml += '</ul>'; // 图例结束标签

      // 更新图例容器
      const legendContainer = document.getElementById('legendContainer');
      if (legendContainer) {
        legendContainer.innerHTML = legendHtml;
      }

      // --- 构建最终 Mermaid 代码字符串 ---
      const mermaidCode = `flowchart LR
    %% 样式定义
    classDef default-field fill:#e1f5fe,stroke:#0288d1,stroke-width:1.5px
    classDef calculated-field fill:#e8f5e9,stroke:#2e7d32,stroke-width:2px
    classDef parameter-field fill:#f3e5f5,stroke:#6a1b9a,stroke-width:1.5px

    %% 节点定义
    ${nodeDefinitions.join('\n    ')}

    %% 连接关系
    ${Array.from(links).join('\n    ')}`;

      return mermaidCode;
    }

    /**
     * 渲染 Mermaid 图表
     * @param {string} mermaidCode - Mermaid 格式的代码字符串
     * @returns {Promise<void>}
     */
    async function renderMermaidDiagram(mermaidCode) {
      const mermaidDiv = document.getElementById('mermaidDiv');
      mermaidDiv.innerHTML = '';
      mermaidDiv.setAttribute('class', 'mermaid');
      mermaidDiv.textContent = mermaidCode;

      try {
        // 重新初始化 mermaid 以确保正确渲染
        mermaid.initialize({
          startOnLoad: false,
          theme: 'default',
          securityLevel: 'loose',
          maxTextSize: 100000,
          maxEdges: 2000, // 增加边的数量限制，允许更复杂的图表
          flowchart: {
            useMaxWidth: false,
            htmlLabels: true,
            curve: 'basis',
            nodeSpacing: 80, // 增加节点间距，使图表更清晰
            rankSpacing: 100, // 增加层级间距，使图表更清晰
            diagramPadding: 20 // 添加图表内边距
          }
        });

        // 渲染图表
        const { svg } = await mermaid.render('graphDiv', mermaidCode);
        mermaidDiv.innerHTML = svg;

        // 确保 SVG 填充容器并设置样式
        const svgElement = mermaidDiv.querySelector('svg');
        if (svgElement) {
          // 设置 SVG 样式
          svgElement.style.width = '100%';
          svgElement.style.height = '100%';
          svgElement.style.maxWidth = 'none';
          svgElement.style.minHeight = '500px'; // 设置最小高度，确保图表有足够的显示空间

          // 初始缩放比例
          window.currentZoom = 1.2; // 默认缩放比例设置为 1.2，使图表初始就有足够大小

          // 添加拖动功能
          makeDraggable(svgElement);

          // 应用初始缩放
          applyZoom(svgElement, window.currentZoom);

          // 添加缩放按钮事件
          document.getElementById('zoomInBtn').addEventListener('click', () => {
            window.currentZoom += 0.2;
            applyZoom(svgElement, window.currentZoom);
          });

          document.getElementById('zoomOutBtn').addEventListener('click', () => {
            if (window.currentZoom > 0.3) {
              window.currentZoom -= 0.2;
              applyZoom(svgElement, window.currentZoom);
            }
          });

          document.getElementById('resetZoomBtn').addEventListener('click', () => {
            window.currentZoom = 1.2; // 重置为初始缩放比例
            applyZoom(svgElement, window.currentZoom);
            // 重置拖动位置
            const g = svgElement.querySelector('g');
            if (g) {
              g.style.transform = `scale(${window.currentZoom})`;
              g.style.transformOrigin = 'center center';
            }
          });
        }

        // 显示成功消息
        addLogEntry('成功', '依赖关系图表渲染完成');
      } catch (renderError) {
        console.error('渲染图表时出错:', renderError);
        addLogEntry('错误', '图表渲染失败: ' + renderError.message);

        // 在错误情况下显示错误信息和原始代码，方便调试
        mermaidDiv.innerHTML = `<div class="error-message">渲染图表时出错: ${renderError.message}</div>
                              <pre class="error-code">${mermaidCode}</pre>`;
      }
    }

    /**
     * 使 SVG 元素可拖动
     * @param {SVGElement} svgElement - SVG 元素
     */
    function makeDraggable(svgElement) {
      const container = document.getElementById('mermaidContainer');
      const g = svgElement.querySelector('g');
      if (!g || !container) return;

      let isDragging = false;
      let startX, startY, startScrollLeft, startScrollTop;

      // 鼠标按下事件
      container.addEventListener('mousedown', (e) => {
        isDragging = true;
        container.style.cursor = 'grabbing';
        startX = e.pageX;
        startY = e.pageY;
        startScrollLeft = container.scrollLeft;
        startScrollTop = container.scrollTop;
      });

      // 鼠标移动事件
      container.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        e.preventDefault();

        // 计算鼠标移动距离，并乘以因子使拖动更流畅
        const dragFactor = 2.0; // 增加拖动距离
        const dx = (e.pageX - startX) * dragFactor;
        const dy = (e.pageY - startY) * dragFactor;

        // 更新滚动位置
        container.scrollLeft = startScrollLeft - dx;
        container.scrollTop = startScrollTop - dy;
      });

      // 鼠标松开事件
      container.addEventListener('mouseup', () => {
        isDragging = false;
        container.style.cursor = 'grab';
      });

      // 鼠标离开事件
      container.addEventListener('mouseleave', () => {
        isDragging = false;
        container.style.cursor = 'grab';
      });

      // 设置初始光标样式
      container.style.cursor = 'grab';
    }

    /**
     * 应用缩放到 SVG 元素
     * @param {SVGElement} svgElement - SVG 元素
     * @param {number} zoomLevel - 缩放级别
     */
    function applyZoom(svgElement, zoomLevel) {
      const container = document.getElementById('mermaidContainer');
      const g = svgElement.querySelector('g');
      if (g && container) {
        // 记录当前滚动位置的百分比
        const scrollLeftPercent = container.scrollLeft / container.scrollWidth;
        const scrollTopPercent = container.scrollTop / container.scrollHeight;

        // 应用缩放
        g.style.transform = `scale(${zoomLevel})`;
        g.style.transformOrigin = 'center center';

        // 等待下一帧更新尺寸
        requestAnimationFrame(() => {
          // 根据百分比计算新的滚动位置，保持相对位置不变
          container.scrollLeft = scrollLeftPercent * container.scrollWidth;
          container.scrollTop = scrollTopPercent * container.scrollHeight;

          // 更新缩放信息显示
          const zoomInfo = document.getElementById('zoomInfo');
          if (zoomInfo) {
            zoomInfo.textContent = `缩放: ${Math.round(zoomLevel * 100)}%`;
          }
        });

        // 更新容器样式，确保可以滚动
        container.style.overflow = 'auto';
      }
    }

    // 设置导出按钮状态
    function setExportButtonsState(disabled) {
      document.getElementById('exportSVGBtn').disabled = disabled;
      document.getElementById('exportPNGBtn').disabled = disabled;
      document.getElementById('exportExcelBtn').disabled = disabled;
      document.getElementById('exportPDFBtn').disabled = disabled;

      document.getElementById('exportJSONBtn').disabled = disabled;
    }



    // 导出SVG
    function downloadSVG() {
      const svg = document.querySelector("#mermaidDiv svg");
      if (!svg) {
        console.error('未找到SVG元素');
        addLogEntry('错误', '未找到SVG元素，无法导出');
        return;
      }

      try {
        const svgData = new XMLSerializer().serializeToString(svg);
        const svgBlob = new Blob([svgData], { type: "image/svg+xml;charset=utf-8" });
        const svgUrl = URL.createObjectURL(svgBlob);

        const downloadLink = document.createElement("a");
        downloadLink.href = svgUrl;
        downloadLink.download = "tableau_relationships.svg";
        document.body.appendChild(downloadLink);
        downloadLink.click();
        document.body.removeChild(downloadLink);
        URL.revokeObjectURL(svgUrl);

        addLogEntry('成功', 'SVG文件导出成功');
      } catch (error) {
        console.error('下载SVG时出错:', error);
        addLogEntry('错误', '下载失败: ' + error.message);
      }
    }

    // 导出PNG
    function downloadPNG() {
      const svg = document.querySelector("#mermaidDiv svg");
      if (!svg) {
        console.error('未找到SVG元素');
        addLogEntry('错误', '未找到SVG元素，无法导出');
        return;
      }

      try {
        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");
        const data = new XMLSerializer().serializeToString(svg);
        const img = new Image();

        img.onload = function () {
          canvas.width = svg.viewBox.baseVal.width || img.width;
          canvas.height = svg.viewBox.baseVal.height || img.height;
          ctx.drawImage(img, 0, 0);

          try {
            const pngUrl = canvas.toDataURL("image/png");
            const downloadLink = document.createElement("a");
            downloadLink.href = pngUrl;
            downloadLink.download = "tableau_relationships.png";
            document.body.appendChild(downloadLink);
            downloadLink.click();
            document.body.removeChild(downloadLink);

            addLogEntry('成功', 'PNG文件导出成功');
          } catch (error) {
            console.error('生成PNG时出错:', error);
            addLogEntry('错误', '下载失败: ' + error.message);
          }
        };

        img.onerror = function (error) {
          console.error('图片加载失败:', error);
          addLogEntry('错误', '图片加载失败');
        };

        img.src = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(data)));
      } catch (error) {
        console.error('下载PNG时出错:', error);
        addLogEntry('错误', '下载失败: ' + error.message);
      }
    }

    /**
     * 将字段数据导出为 Excel 文件
     */
    function exportExcel() {
      if (!processedData || !processedData.fields || processedData.fields.length === 0) {
        addLogEntry('错误', '没有可导出的数据。请先上传并处理 Tableau 文件');
        return;
      }

      try {
        addLogEntry('信息', '正在创建 Excel 报告...');

        // 准备 SheetJS 需要的数据格式 (对象数组)
        const headers = ['字段名称', '数据类型', '类型', '计算公式', '数据源', '字段 ID'];
        const dataForSheet = processedData.fields.map(field => ({
          '字段名称': (field.field_caption || field.name).replace(/[\[\]]/g, ''), // 清理名称
          '数据类型': field.field_datatype || field.datatype || '',
          '类型': getFieldTypeDisplayName(field),
          '计算公式': field.field_calculation || field.formula || '',
          '数据源': field.datasource_caption || field.datasource || '',
          '字段 ID': field.field_id || field.id || ''
        }));

        // 使用 SheetJS 工具函数将 JSON 数据转换为工作表对象
        // header 参数指定了列的顺序和名称
        const ws = XLSX.utils.json_to_sheet(dataForSheet, { header: headers });

        // 设置列宽 (wch 单位是字符宽度近似值)
        ws['!cols'] = [
          { wch: 30 }, // 字段名称
          { wch: 15 }, // 数据类型
          { wch: 18 }, // 类型
          { wch: 60 }, // 计算公式 (给足宽度)
          { wch: 25 }, // 数据源
          { wch: 40 }  // 字段 ID
        ];

        // 创建一个新的工作簿对象
        const wb = XLSX.utils.book_new();
        // 将工作表添加到工作簿，并命名为 '字段详情'
        XLSX.utils.book_append_sheet(wb, ws, '字段详情');

        // 生成 Excel 文件名
        const filename = currentFile ? currentFile.name.replace(/\.[^/.]+$/, '') : 'tableau_workbook';
        const excelFileName = `${filename}_字段分析_${new Date().toISOString().slice(0, 10)}.xlsx`;

        // 使用 SheetJS 的 writeFile 函数生成并触发浏览器下载
        XLSX.writeFile(wb, excelFileName);

        addLogEntry('成功', `Excel 文件 '${excelFileName}' 已生成。`);
      } catch (error) {
        console.error('生成 Excel 时出错:', error);
        addLogEntry('错误', '生成 Excel 失败: ' + error.message);
      }
    }

    /**
     * 获取字段类型的显示名称
     * @param {Object} field - 字段对象
     * @returns {string} - 返回字段类型的中文显示名称
     */
    function getFieldTypeDisplayName(field) {
      if (field.category === 'Calculated_Field' || field.type === 'calculation') {
        return '计算字段';
      } else if (field.category === 'Parameters' || field.type === 'parameter') {
        return '参数';
      } else {
        return '默认字段';
      }
    }

    /**
     * 将字段数据导出为 PDF 文件
     */
    function exportPDF() {
      if (!processedData || !processedData.fields || processedData.fields.length === 0) {
        addLogEntry('错误', '没有可导出的数据。请先上传并处理 Tableau 文件');
        return;
      }

      try {
        addLogEntry('信息', '正在创建 PDF 报告...');

        // 创建 jsPDF 实例
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF({
          orientation: 'landscape', // 横向打印，以容纳更多列
          unit: 'pt',              // 使用点作为单位
          format: 'a4'             // A4 纸张大小
        });

        // 准备表格数据
        const data = processedData.fields.map(field => [
          (field.field_caption || field.name).replace(/[\[\]]/g, ''), // 字段名称，清理方括号
          field.field_datatype || field.datatype || '',               // 数据类型
          getFieldTypeDisplayName(field),                             // 字段类型
          field.field_calculation || field.formula || '',             // 计算公式
          field.datasource_caption || field.datasource || ''          // 数据源
        ]);

        // 生成文件名
        const filename = currentFile ? currentFile.name.replace(/\.[^/.]+$/, '') : 'tableau_workbook';
        const pdfFileName = `${filename}_字段分析_${new Date().toISOString().slice(0, 10)}.pdf`;

        // 添加标题
        doc.setFontSize(16);
        doc.text(`Tableau 字段分析: ${filename}`, 40, 40);

        // 添加统计信息
        doc.setFontSize(10);
        const calcCount = processedData.fields.filter(f => f.category === 'Calculated_Field' || f.type === 'calculation').length;
        const paramCount = processedData.fields.filter(f => f.category === 'Parameters' || f.type === 'parameter').length;
        const defaultCount = processedData.fields.filter(f => f.category === 'Default_Field' || (f.type !== 'calculation' && f.type !== 'parameter')).length;
        doc.text(`共 ${processedData.fields.length} 个字段（${calcCount} 个计算字段，${paramCount} 个参数，${defaultCount} 个默认字段）`, 40, 60);

        // 创建表格
        doc.autoTable({
          head: [['字段名称', '数据类型', '字段类型', '计算公式', '数据源']],
          body: data,
          startY: 80, // 表格起始位置，留出空间给标题和统计信息
          theme: 'grid',
          styles: {
            fontSize: 8,     // 小字体以容纳更多内容
            cellPadding: 2,  // 单元格内边距
            overflow: 'linebreak' // 文本过长时自动换行
          },
          columnStyles: {
            0: { cellWidth: 80 },  // 字段名称
            1: { cellWidth: 60 },  // 数据类型
            2: { cellWidth: 60 },  // 字段类型
            3: { cellWidth: 250 }, // 计算公式 (给足宽度)
            4: { cellWidth: 80 }   // 数据源
          },
          didDrawPage: function(data) {
            // 添加页脚
            doc.setFontSize(8);
            doc.text(`生成日期: ${new Date().toLocaleDateString()}`, 40, doc.internal.pageSize.height - 20);
            doc.text(`页码: ${doc.internal.getNumberOfPages()}`, doc.internal.pageSize.width - 100, doc.internal.pageSize.height - 20);
          }
        });

        // 保存 PDF
        doc.save(pdfFileName);

        addLogEntry('成功', `PDF 文件 '${pdfFileName}' 已生成。`);
      } catch (error) {
        console.error('生成 PDF 时出错:', error);
        addLogEntry('错误', '生成 PDF 失败: ' + error.message);
      }
    }



    /**
     * 将字段数据导出为 JSON 文件
     */
    function exportJSON() {
      if (!processedData || !processedData.fields || processedData.fields.length === 0) {
        addLogEntry('错误', '没有可导出的数据。请先上传并处理 Tableau 文件');
        return;
      }

      try {
        addLogEntry('信息', '正在创建 JSON 文件...');

        // 准备导出数据
        const exportData = {
          metadata: {
            exportDate: new Date().toISOString(),
            filename: currentFile ? currentFile.name : 'tableau_workbook',
            totalFields: processedData.fields.length,
            calculatedFields: processedData.fields.filter(f => f.category === 'Calculated_Field' || f.type === 'calculation').length,
            parameters: processedData.fields.filter(f => f.category === 'Parameters' || f.type === 'parameter').length,
            defaultFields: processedData.fields.filter(f => f.category === 'Default_Field' || (f.type !== 'calculation' && f.type !== 'parameter')).length,
            relationships: processedData.relationships.length
          },
          fields: processedData.fields,
          relationships: processedData.relationships
        };

        // 创建 JSON 内容，使用缩进使其更易读
        const jsonContent = JSON.stringify(exportData, null, 2);

        // 生成文件名
        const filename = currentFile ? currentFile.name.replace(/\.[^/.]+$/, '') : 'tableau_workbook';
        const jsonFileName = `${filename}_字段分析_${new Date().toISOString().slice(0, 10)}.json`;

        // 创建 Blob 并下载
        const blob = new Blob([jsonContent], { type: 'application/json' });
        const url = URL.createObjectURL(blob);

        const link = document.createElement('a');
        link.setAttribute('href', url);
        link.setAttribute('download', jsonFileName);
        link.style.visibility = 'hidden';

        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url); // 释放 URL 对象

        addLogEntry('成功', `JSON 文件 '${jsonFileName}' 已生成。`);
      } catch (error) {
        console.error('生成 JSON 时出错:', error);
        addLogEntry('错误', '生成 JSON 失败: ' + error.message);
      }
    }
  </script>
</body>

</html>